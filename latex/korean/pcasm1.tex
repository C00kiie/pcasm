% -*-latex-*-

\chapter{시작하기 앞서서}
\section{기수법}
% 번역이 약간 odd 함
컴퓨터 내부의 메모리는 수들로 구성되어 있다. 컴퓨터 메모리는 그 수들을 
10 개의 숫자를 이용하는 십진법(decimal)을 이용하여 저장하지 않는다. 그 대신 
하드웨어를 매우 단순화 시키는 이진법(binary)을 이용하여 컴퓨터는 모든 정보를
저장한다. 먼저, 십진 체계에 대해 알아 보도록 하자.

\subsection{십진법\index{십진법}}

십진체계에서는 10 개의 숫자(0-9)들을 이용하여 수를 나타낸다. 십진법에서 수의 각 자리
숫자는 그 수에서의 위치에 대한 10 의 멱수로 나타나게 된다. 예를 들면

\begin{displaymath}
234 = 2 \times 10^2 + 3 \times 10^1 + 4 \times 10^0
\end{displaymath}

\subsection{이진법\index{이진법|(}}

이진체계에서는 오직 2 개의 숫자(0,1) 만을 이용하며 십진법과는 달리 2 를 기준으로 나타난다.
이진수의 각 자리 숫자는 그 수에서의 위치에 대한 2 의 멱수로 나타나게 된다.(참고로, 
이진수에서 각 자리 숫자를 비트(bit)라고 부른다) 예를 들자면 

\begin{eqnarray*}
11001_2 & = & 1 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 
             + 1 \times 2^0 \\
& = & 16 + 8 + 1 \\
& = & 25 
\end{eqnarray*}

위 예를 통해 어떻게 이진수가 십진수로 바뀌어지는지 알 수 있다. 아래 표 ~\ref{tab:dec-bin}에서 일부 십진수들이
이진수로 어떻게 나타나는지 보여주고 있다. 

\begin{table}[t]
\begin{center}
\begin{tabular}{||c|c||cc||c|c||}
\hline
십진수 & 이진수 & & & 십진수 & 이진수 \\
\hline
0       & 0000   & & & 8       & 1000 \\
\hline
1       & 0001   & & & 9       & 1001 \\
\hline
2       & 0010   & & & 10      & 1010 \\
\hline
3       & 0011   & & & 11      & 1011 \\
\hline
4       & 0100   & & & 12      & 1100 \\
\hline
5       & 0101   & & & 13      & 1101 \\
\hline
6       & 0110   & & & 14      & 1110 \\
\hline
7       & 0111   & & & 15      & 1111 \\
\hline
\end{tabular}
\caption{0 부터 15 까지의 십진수들을 이진수로 나타냄\label{tab:dec-bin}}
\end{center}
\end{table}


\begin{figure}[h]
\begin{center}
\begin{tabular}{|rrrrrrrrp{.1cm}|p{.1cm}rrrrrrrr|}
\hline
& \multicolumn{7}{c}{이전에 올림(carry) 없음} & & & \multicolumn{7}{c}{이전에 올림 있음} & \\
\hline
&  0 & &  0 & &  1 & &  1 & & &  0 & &  0 & &  1 & & 1  & \\
& +0 & & +1 & & +0 & & +1 & & & +0 & & +1 & & +0 & & +1 &  \\
\cline{2-2} \cline{4-4} \cline{6-6} \cline{8-8} \cline{11-11} \cline{13-13} \cline{15-15} \cline{17-17}
& 0  & & 1  & & 1  & & 0  & & & 1  & & 0  & & 0  & & 1 & \\
&    & &    & &    & & c  & & &    & & c  & & c  & & c & \\
\hline
\end{tabular}

\caption{이진수의 덧셈 (c 는 \emph{올림(carry)}을 나타낸다 )\label{fig:bin-add}}
%TODO: Change this so that it is clear that single bits are being added,
%not 4-bit numbers. Ideas: Table or do sums horizontally.
\index{이진수의 덧셈}
\end{center}
\end{figure}

그림 ~\ref{fig:bin-add} 는 어떻게 두 이진숫자가 더해지는지 ({\em i.e.}, 비트(bits)) 보여주고 있다.
여기, 그 예가 있다.
\newline
\begin{center}
\begin{tabular}{r}
 $11011_2$ \\
+$10001_2$ \\
\hline
$101100_2$ \\
\end{tabular}
\end{center}

누군가가 아래와 같은 십진 나눗셈을 하였다고 하자. 
\[ 1234 \div 10 = 123\; r\; 4 \]
그는 이 나눗셈이 피제수의 가장 오른쪽 숫자를 띄어버리고 나머지 숫자를 오른쪽으로 한 자리 쉬프트 했다는 사실을 
알 수 있다. 이진체계에서는 2 로 나누는 연산을 통해 위와 동일한 작업을 발생시킬 수 있다. 예를 들어 아래와 같은
이진 나눗셈을 생각하자. \footnote{참고로 수 옆에 아래 첨자로 적힌 2 는 이 숫자가 십진법으로 나타낸 수가 아니라
이진법으로 나타낸 수 임을 알려준다}:
\[ 1101_2 \div 10_2 = 110_2\; r\; 1 \]
이 사실을 통해서 어떤 십진수를 값이 같은 이진수로 바꿀 수 있다는 것을 알 수 있다. 이는 그림 ~\ref{fig:dec-convert}
에서 나타난다. 이 방법은 가장 오른쪽의 비트 부터 찾아 나가는데 그 비트를 흔히 \emph{최하위 비트(least significant bit, lsb)} 
라 부른다. 또한 가장 왼쪽의 비트는 \emph{최상위 비트(most significant bit, msb)} 라고 부른다. 메모리의 가장 기본적인
단위는 \emph{바이트(byte)} 라 부르는 8 개의 비트들로 이루어져 있다. 

\index{이진법|)}

\begin{figure}[t]
\centering
\fbox{\parbox{\textwidth}{
\begin{eqnarray*}
\mathrm{십진수} & \mathrm{이진수} \\
25 \div 2 = 12\;r\;1 & 11001 \div 10 = 1100\;r\;1 \\
12 \div 2 = 6\;r\;0  & 1100 \div 10 = 110\;r\;0 \\
6 \div 2 = 3\;r\;0   & 110 \div 10 = 11\;r\;0 \\
3 \div 2 = 1\;r\;1   & 11 \div 10 = 1\;r\;1 \\
1 \div 2 = 0\;r\;1   & 1 \div 10 = 0\;r\;1 \\
\end{eqnarray*}

\centering
따라서 $25_{10} = 11001_{2}$
}}
\caption{십진수의 변환 \label{fig:dec-convert}}
\end{figure}

\subsection{16 진법\index{16진법|(}}

  16진수들은 16 을 밑으로 하여 나타내어 진다. 16 진수들은 흔히 자리수가 큰 이진수들의 크기를 줄이기 위해
  사용된다. 16 진수가 16 개의 숫자를 사용하기 때문에 6 개의 숫자가 모자르게 된다. 이 때문에 9 다음으로
  나타나는 숫자들은 영어 대문자 A, B, C, D, E, F 를 사용하게 된다. 따라서 16 진수 A 는 10 진수 10 과 동일한
  값을 가지며 B 는 11, 그리고 F 는 15 의 값을 가진다. 16 진수는 16 을 밑으로 하여 수를 나타내는데 아래 예를 보면
  
\begin{eqnarray*}
%\rm
2BD_{16} & = & 2 \times 16^2 + 11 \times 16^1 + 13 \times 16^0 \\
         & = & 512 + 176 + 13 \\
         & = & 701 \\
\end{eqnarray*}
십진수를 16 진수로 변환하기 위해서는 우리가 앞서 이진수를 십진수로 변환하는데 사용했던 방법을 이용하면
된다. 다만, 이진수로 변환하는 것은 2 로 나누는 것이였지만 16 진수로 변환하는 것은 16 으로 나누어 주면 된다.
예시로 아래 그림 ~\ref{fig:hex-conv} 을 보면 알 수 있다. 

\begin{figure}[t]
\centering
\fbox{\parbox{\textwidth}{
\begin{eqnarray*}
589 \div 16 & = & 36\;r\;13 \\
36 \div 16 & = & 2\;r\;4 \\
2 \div 16 & = & 0\;r\;2 \\
\end{eqnarray*}

\centering
결과적으로 $589 = 24\mathrm{D}_{16}$
}}
\caption{\label{fig:hex-conv}}
\end{figure}

16 진수가 유용한 이유는 바로 2진수를 손쉽게 16 진수로 바꿀 수 있기 때문이다. 이진수들은 그 자리수가
너무 커서 다루기 불편하지만 ~16 진수들은 그 길이가 훨씬 짧아지므로 표현하기가 매우 쉬워진다. 

16 진수를 2 진수로 바꾸는 방법은 단지 16 진수의 각 자리수를 4 비트의 이진수로 바꾸어 주면 된다. 
예를 들어 $\mathrm{24D}_{16}$ 은 \mbox{$0010\;0100\; 1101_2$} 으로 변환된다. 주의 해야 할 점은
16 진수의 모든 자리수는 반드시 4 비트로 바꾸어 주어야 하는데 (다만 16 진수의 첫 번째 자리수는 꼭
그렇게 할 필요는 없다) 왜냐하면 4 를 이진수로 바꾸었을 때 $\mathrm{4}_{16} = {100}_{2}$ 라고 해서
그냥 100 으로 한다면 그 결과가 완전히 달라지게 된다. 
마찬가지로 이진수를 16 진수로 바꾸는 것도 매우 쉬운데 오른쪽 끝에서 부터 4 비트 씩 끊어 가면서 
각각을 16 진수로 바꾸면 된다. 물론 이 때 반드시 오른쪽 끝에서 부터 변환해야 한다.\footnote{왜 그래야
하는지 이해가 잘 가지 않는다면 직접 어떤 이진수를 골라서 왼쪽 부터 16 진수로 변환해 보아라} 
예를 들면 \newline

\begin{tabular}{cccccc}
$110$ & $0000$ & $0101$ & $1010$ & $0111$ & $1110_2$ \\
  $6$ & $0$    &   $5$  &   A  &  $7$   &    $\mathrm{E}_{16}$ \\
\end{tabular}\newline

4 비트의 이진수를 \emph{니블(nibble)} \index{니블} 이라 하고, 따라서 16 진수의 각 자리수는 1 개의 니블에 대응된다.
또한 2 개의 니블은 1 바이트를 나타내며, 1 개의 바이트는 2 자리 16 진수에 대응된다. 1 바이트가 가질 수 있
는 값의 범위는 이진수로 나타내면 0 부터 11111111 , 16 진수로 나타내면 0 부터 FF, 십진수로 나타내면 0 부터 255 까지 임을
알 수 있다. 
\index{16진법|)}

\section{컴퓨터의 구조}

\subsection{메모리\index{메모리|(}}
메모리의 기본적인 단위는 바이트 이다. \index{바이트} \MarginNote{메모리의 크기를 
나타내는 단위들은 킬로바이트(~$2^{10} = 1,024$ 바이트), 메가바이트(~$2^{20} = 1,048,576$ 바이트) 
그리고 기가바이트(~$2^{30} = 1,073,741,824$ 바이트).} 만약 어떤 컴퓨터가 32 메가바이트의 메모리를 가진
다면 그 컴퓨터는 대략 3200 만 바이트의 정보를 보관할 수 있다. 메모리의 각 바이트는 그림 ~\ref{fig:memory} 에
잘 나와 있듯이 주소(adress)라 불리는 고유의 값을 가지고 있다. 

\begin{figure}[ht]
\begin{center}
\begin{tabular}{rcccccccc}
주소 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
\cline{2-9}
메모리 & \multicolumn{1}{|c}{2A}  & \multicolumn{1}{|c}{45}  
       & \multicolumn{1}{|c}{B8} & \multicolumn{1}{|c}{20} 
       & \multicolumn{1}{|c}{8F} & \multicolumn{1}{|c}{CD} 
       & \multicolumn{1}{|c}{12} & \multicolumn{1}{|c|}{2E} \\
\cline{2-9}
\end{tabular}
\caption{ 메모리 주소 \label{fig:memory} }
\end{center}
\end{figure}

\begin{table}
\begin{center}
\begin{tabular}{|l|l|}
\hline
워드(word) & 2 바이트 \\ \hline
더블워드(double word) & 4 바이트 \\ \hline
쿼드워드(quad word) & 8 바이트 \\ \hline
패러그래프(paragraph) & 16 바이트 \\ \hline
\end{tabular}
\caption{메모리의 단위 \label{tab:mem_units} }
\end{center}
\end{table}


보통 메모리는 단일 바이트 보다는 여러개의 바이트들의 묶음으로 많이 사용된다. PC 아키텍쳐에서는
그 묶음들을 표 ~\ref{tab:mem_units} 에서 나타나는 것 처럼 이름 붙인다. 

메모리에 있는 모든 데이터들은 수 이다. 문자들은 \emph{문자 코드(character code)} 에 나타난 숫자
들에 대응되어 기록된다. 문자 코드 중에서 가장 유명한 것으로는 \emph{아스키(ASCII, American
Standard Code for Information Interchange)} 코드를 들 수 있다. 현재 새롭게 아스키 코드를 대체해
나가고 있는 코드는 유니코드(Unicode) 이다. 유니코드와 아스키코드의 가장 큰 차이점은 아스키 코드에서는
한 개의 문자를 나타내기 위해 1 바이트를 사용하지만 유니코드는 2 바이트(혹은 \emph{워드}) 를 사용한다. 
예를 들어서 아스키코드에서는 대문자 \emph{A} 를 나타내기 위해 바이트 $41_{16}$($65_{10}$) 를 사용하지만
유니코드에서는 워드 $0041_{16}$ 을 사용한다.아스키코드가 1 바이트 만을 사용하기 때문에 오직 256 개의 서로
다른 문자들만 사용할 수 있으나 \footnote{사실 아스키코드는 오직 하위 7 비트 만을 사용하므로 오직 128 개의 
서로 다른 값들만 나타낼 수 있다.} 반면에 유니코드는 아스키코드를 확장하여 훨씬 많은 문자들을 사용할 수 있게
하였다. 이를 통해 전 세계의 많은 언어들의 문자를 나타낼 수 있게 되었다. 

\index{메모리|)}

\subsection{CPU\index{CPU|(}}

중앙처리장치(CPU) 는 명령을 수행하는 장치이다. 보통 CPU 들이 수행하는 명령들은 매우 단순하다. 명령들은 대부분
CPU 자체에 있는 특별한 데이타 저장소인 \emph{레지스터} \index{레지스터}에 들어 있는 값들을 필요로 한다. 
CPU 는 레지스터에 있는 데이터에 메모리에 있는 데이터 보다 훨씬 빠른 속도로 접근 할 수 있다. 그러나 CPU 한 개에
있는 레지스터의 수는 제한적이기 때문에 프로그래머는 반드시 현재 사용되고 있는 데이터들만 레지스터에 보관
하도록 해야 한다. 
% 번역이 미숙함. 특히 아래 Clock 설명도 좀더 확실한 이해가 필요하다.
CPU 가 실행하는 명령들은 CPU 의 \emph{기계어(Machine language)} \index{기계어}에 의해 작성되어 있다. 기계 프로그램은 
고급 언어들 보다 훨씬 간단한 구조를 가지고 있다. 기계어의 명령들은 숫자들에 대응이 된다. CPU 는 이러한 명령들을 
 빠른 속도로 해석하여 효율적으로 실행해야만 한다. 따라서 기계어는 이러한 점을 항상 
염두에 두어 디자인 되기 때문에 인간이 해석하기에는 매우 난해한 면이 있다. 다른 언어로 쓰여진 프로그램들은
실행되기 위해서는 반드시 CPU 가 해석할 수 있는 기계어로 변환되어야만 한다. 따라서 특정한 컴퓨터 아키텍쳐에 대한 기계어 코드로 
소스를 바꾸어 주는 프로그램을 \emph{컴파일러(compiler)} \index{컴파일러} 라고 한다. 보통 각 CPU 마다 특정한
기계어를 가지고 있다. 이 때문에  Mac 에서 쓰여진 코드가 IBM PC 에서 잘 작동이 되지 않는다. 

컴퓨터는 \emph{클록(clock)} \index{clock} 을 이용하여 \MarginNote{\emph{GHz} 는 기가헤르츠의 약자로 초당 10억 번의 
펄스가 발생했다는 뜻이다.  예로 1.5 GHz CPU 는 초당 15억번의 펄스가 발생한다.} 명령들의 실행을 동기화 한다.
클록은 특정한 진동수에 따라 펄스를 방출하는데 이 진동수를 \emph{클록 속도} 라고 한다. 당신이 만약 1.5GHz 의 컴퓨터를 
구매 한다면 1.5Ghz 가 바로 이 컴퓨터의 클록의 진동수이다. \footnote{사실 클록 펄스는 컴퓨터의 여러 다른 부분들에서도
많이 사용되는데 그 부분들의 클록 속도는 CPU 와 다르다.} 우리가 메트로놈을 이용하여 음악을 정확한 리듬으로 연주할 
수 있는 것 처럼 CPU 도 언제나 일정하게 클록에서 방출되는 펄스를 이용하여 명령을 정확하게 수행 할 수 있다. 각 명령이
필요로 하는 클록의 진동 횟수(보통 \emph{사이클} 이라 부른다) 는 CPU 의 세대와 모델에 따라 차이가 난다. 


\subsection{CPU 의 80x86 계열 \index{80x86!CPU}}

IBM 형의 PC 는 인텔의 80x86 계열의 CPU 를 장착하고 있다. 이 계열의 CPU 들은 모두 동일한 기반의 기계어를 사용한다. 
최근에 출시된 것들의 경우 그 기능이 대폭 강화되었다. 

\begin{description}

\item[8088,8086:]   
이 CPU 들은 초기의 PC 에서 사용되었던 것들이다. 이들은 AX, BX, CX, DX, SI, DI, BP, SP, CS, DS, SS,
ES, IP, FLAGS 와 같은 16비트 레지스터들을 사용한다. 뿐만 아니라 최대 1 MB 의 메모리만 지원하며 오직 
실제 모드에서만 실행된다. 이 모드에서는 하나의 프로그램이 메모리의 모든 부분에 접근할 수 있다. 심지어
다른 프로그램이 그 부분을 이미 사용하고 있다고 해도 말이다. 이 때문이 디버깅과 보안을 유지하기가 매우
힘들어 지게 된다. 뿐만 아니라 프로그램 메모리는 반드시 \emph{세그먼트(segments)} 들로 나누어 져야 하는
데 각각의 세그먼트들의 크기는 64KB 를 넘을 수 없다. 

\item[80286:] 
이 CPU 는 AT 계열의 PC 들에서 사용되었다. 이 CPU 는 몇 개의 새로운 명령들이 추가된 8088/86 기계어를 
사용하였다. 그러나 이 CPU 의 가장 중요한 새기능은 바로 \emph{16 비트 보호 모드(16-bits protected mode)} 이다. 
이 모드에서는 최대 16 MB 의 메모리에 접근 할 수 있고 특정한 프로그램이 다른 프로그램의 메모리에 함부로
접근하는 것을 방지해 준다. 하지만 아직도 각각의 프로그램들은 64 KB 보다 작아야 하는 세그먼트들에서만 실행 될 수 있었다.

\item[80386:] 
이 CPU 는 80286 CPU 를 크게 발전시킨 것이다. 첫번째로, 기존의 16 비트 레지스터들을 32 비트 레지스터
(EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP, EIP) 로 확장하였고 새로운 16 비트 레지스터인 FS 와 GS 를 추가하였다.
또한 이 CPU 는 \emph{32 비트 보호 모드(32-bit protected mode)} 를 지원한다. 이 모드에서는 최대 4 GB 의 메모리를
사용할 수 있다. 아직도 프로그램들은 세그먼트들에 나뉘어 들어가야만 하지만 각 세그먼트의 크기는 최대
4 GB 까지 될 수 있다.  

\item[80486/펜티엄/펜티엄 프로:]
이 CPU 들은 기존의 CPU 들과는 크게 달라진 것이 없다. 다만 명령들의 연산속도가 매우 빨라졌다.

\item[펜티엄 MMX:] 
이 프로세서에는 MMX(멀티미디아 확장, MultiMedia eXtensions) 명령이 추가되었다. 이 명령은 자주 실행되는
그래픽 관련 명령들의 실행 속도를 향상 시켰다. 

\item[펜티엄 II:] 
이는 펜티엄 프로 프로세서에 MMX 명령들이 추가된 프로세서 이다. (펜티엄 III 의 경우 단지 II 보다 빨라진 것이다.) 

\end{description}
\index{CPU|)}

\subsection{8086 16비트 레지스터\index{레지스터|(}}

기존의 8086 CPU 는 4 개의 16 비트 범용 프로세서들을 지원했는데 이는 AX, BX, CX, 그리고 DX 이다. 각각의 레지스터들은
2 개의 8 비트 레지스터들로 나뉘어 질 수 있다. 예를 들어 AX 레지스터는 AH, AL 레지스터로 나뉠 수 있는데 이는 그림 ~\ref{fig:AX_reg}
에 잘 나타나 있다. AH 레지스터는 AX 의 상위 8 비트를 나타내고, AL 은 AX 의 하위 8 비트를 나타낸다. AH 와 AL 을 종종 독립적인
1 바이트 레지스터 들로 사용된다. 그러나 두 레지스터들이 AX 와 다른 것이라고 생각하면 안된다. AX 레지스터의 값을 바꾸게 되면
AH 와 AL 의 값도 바뀌고 AH 와 AL 의 값을 바꾸면 AX 의 값이 바뀐다. 범용 레지스터들은 산술 연산과 데이터 이동 명령 들에서 
잘 쓰인다. 

\begin{figure}
\begin{center}
\begin{tabular}{cc}
\multicolumn{2}{c}{AX} \\
\hline
\multicolumn{1}{||c|}{AH} & \multicolumn{1}{c||}{AL} \\
\hline
\end{tabular} 
\caption{AX 레지스터 \label{fig:AX_reg} }
\end{center}
\end{figure}

CPU 에는 2 개의 SI 와 DI 라 불리는 16 비트 색인 레지스터가 있다. \index{레지스터!색인} 이 들은 포인터로 자주 쓰이지만 범용 레지스터
들과 같은 용도로 종종 쓰인다. 그러나 색인 레지스터들은 범용 레지스터와는 달리 2 개의 8 비트 레지스터들로 나누어 질 수 없다.

16 비트 BP 와 SP 레지스터들은 기계어 스택에 들어 있는 데이터의 위치를 가리키는데 쓰인다. 이 2 개의 레지스터를 각각 기준 포인터
\index{레지스터!위치 레지스터} 와 스택 포인터\index{레지스터!스택 포인터} 라고 부른다. 이 들에 대해선 나중에 다루기로 하자. 

16 비트 CS, DS, SS, ES 레지스터들은 \emph{세그먼트 레지스터(segment register)} 라고 부른다. \index{레지스터!세그먼트} 이 프로그램의 각 부분에서 
메모리의 어떤 부분이 사용되는지 가리킨다. CS 는 코드 세그먼트(Code Segment), DS 는 데이타 세그먼트(Data Segment), SS 는 스택 세그
먼트(Stack Segment), 그리고 ES 는 보조 세그먼트(Extra Segment) 의 약자 이다. ES 는 임시적인 세그먼트 레지스터로 사용된다. 이 레지스터
들에 대한 자세한 내용은 %~\ref{실제 모드} 와 \ref{16비트 보호 모드} 현재 이 부분이 정의되 있지 않다고 오류뜸
에서 다룰 것이다. 

명령 포인터(IP) \index{레지스터!IP} 레지스터는 CS 레지스터와 함께 사용되는데 이는 CPU 에서 다음으로 실행될 명령의 주소를 저장한다. 보통 CPU
에서 명령이 하나 실행되면 IP 는 메모리 상에서 그 다음으로 실행될 명령을 가리키게 된다. 

플래그(FLAG) \index{레지스터!플래그} 레지스터들은 이전에 실행된 명령들의 중요한 결과값들을 저장하고 있다. 이 값들은 플래그 레지스터의 각각
의 비트에 저장되는데 예를 들며 이전 연산의 결과가 0 이 였다면 플래그 레지스터의 Z 비트의 값은 1 이되고 0 이 아니라면 0 이 된다. 
모든 명령이 플래그 레지스터의 비트 값들을 바꾸는 것은 아니며 이 책의 부록에 보면 어떠한 명령들이 플래그 레지스터의 값에 영향을 주는지 알 수 있다.

\subsection{80386 32비트 레지스터\index{레지스터!32비트}}

80386 과 그 이후에 출시된 프로세서들은 모두 확장 레지스터를 가지고 있다. 예를 들어 16 비트 AX 레지스터는 32 비트로 확장되었다. 이 때
하위 호환성을 위해 AX 는 계속 16 비트 레지스터로 남아 있고 그 대신 EAX 가 확장된 32 비트 레지스터를 가리키게 된다. AL 이 단지 AX 의 하위
8 비트인 것 처럼 AX 도 단지 EAX 의 하위 16 비트를 나타낸다. 이 때, EAX 의 상위 16 비트에 직접적으로 접근 할 수 있는 방법은 없다. 다른
확장된 레지스터들은 EBX, ECX, EDX, ESI, 그리고 EDI 가 있다. 

다른 많은 수의 레지스터들도 확장되었다. BP 는 EBP\index{레지스터!베이스 포인터}로, SP 는 ESP\index{레지스터!스택 포인터}로, FLAGS 는 
EFLAGS\index{레지스터!EFLAGS}로, 그리고 IP 는 EIP\index{레지스터!EIP}가 되었다. 그러나 32 비트 보호 모드에서는 범용 레지스터를 뺀 나머지 레지스터들은
모두 확장된 것으로만 사용해야 한다. 

80386 에선 아직 세그먼트 레지스터들이 16 비트로 남아 있다. 하지만 새로운 2 개의 세그먼트 레지스터들이 추가되었는데 바로 FS 와 GS 이다.
\index{레지스터!세그먼트} 이 레지스터들은 단지 ES 와 같이 임시적인 세그먼트 레지스터들로 사용된다. 

\emph{워드(word)} 라는 단어는 CPU 데이터 레지스터의 크기로 정의된다. \index{워드} 80x86 계열 에서는 위 정의가 약간 혼란스럽다. 
아래 표 ~\ref{tab:mem_units} 에 나온 것 처럼 \emph{워드} 는 2 바이트 (혹은 16 비트) 로 정의됨을 알 수 있다. 이는 처음 8086 이 발표되었을 때
정해진 것이다. 하지만 80386 이 개발 되었을 때 레지스터의 크기가 바뀌었는데도 불구하고 기존의 \emph{워드} 의 정의를 그대로 남기기로 했다.
\index{레지스터|)}

\subsection{실제 모드}\index{실제 모드|}

실제 모드 에선 \MarginNote{그렇다면 DOS 의 640KB 제한은 어디서 나타난 것일까? BIOS 는 비디오 스크린과 같은 하드웨어를 위해 1MB 의 일부분을 필요로 한다}
메모리 사용이 오직 1 MB ($2^{20}$ 바이트) 로 제한된다. 이는 00000 부터 FFFFF 에 해당하는 값이다. 따라서 메모리의 주소를 나타내기 위해선 20 비트의
숫자를 저장할 수 있는 레지스터가 필요한데 안타깝게도 8086 의 레지스터는 모두 16 비트 밖에 되지 않으므로 그럴 수 없다. 하지만 인텔은 하나의 메모리 
주소를 정하기 위해 2 개의 16 비트 값을 사용하여 문제를 해결하였다. 처음의 16 비트 값을 \emph{실렉터(selector)} 라고 부른다. 실렉터의 값은 반드시
세그먼트 레지스터에 저장되어야만 한다. 두 번째 16 비트 값을 \emph{오프셋(offset)} 이라 부른다. 메모리의 물리 주소는 32 비트의 \emph{실렉터:오프셋} 쌍
으로 나타나며 그 값은
\[ 16 * \text{selector} + \text{offset} \]
이다. 16 을 곱하는 것은 16 진수에서는 단순히 오른쪽 끝에 0 을 하나 추가하는 것이므로 매우 쉬운 작업이다. 예를 들어 특정한 메모리 공간의 주소가 047C:0048 
로 주어진다면 이는
\begin{center}
\begin{tabular}{r}
047C0 \\
+0048 \\
\hline
04808 \\
\end{tabular}
\end{center}
에 데이터가 저장되어 있다는 것이다. 사실상 실릭터의 값은 언제나 16 의 배수(패러그래프 수)가 된다. (표 ~\ref{tab:mem_units} 참조)

그러나 위와 같은 방법도 몇 가지 단점이 있는데 : 
\begin{itemize}
\item
하나의 실렉터를 사용하면 최대 64 KB 의 메모리 까지 밖에 사용 할 수 없다. 따라서 만일 프로그램이 64KB 보다 더 큰 메모리를
필요로 한다면 하나의 실렉터 만으로는 충분하지 못할 것이다. 이 때문에 프로그램이 64KB 이 상의 메모리를 사용시 
프로그램은 반드시 64KB 이하의 조각들로 쪼개져야 한다 (이 조각들을 \emph{세그먼트}\index{메모리!세그먼트} 라
부른다) 만약 프로그램의 명령이 다른 세그먼트로 넘어갈 경우 CS 의 값도 반드시 달라져야 한다. 큰 데이터를 다룰 때 DS 레지스터
에서도 비슷한 일이 발생하게 된다. 상당히 짜증나는 일이다!

\item 
위와 같이 주소 지정을 해준다면 메모리의 공간들은 유일한 주소값을 가지지 않는다. 예를 들어 물리 주소 04808 은 
047C:0048, 047D:0038, 047E:0028, 047B:0058 등과 같이 나타날 수 있다. 이 때문에 두 개의 주소값이 같은지 비교시 
복잡해진다.  

\end{itemize}

\subsection{16비트 보호 모드}\index{보호 모드!16비트}

80286 의 16비트 보호 모드에서 실렉터의 값들은 실제 모드에서의 값과 다른 방식으로 해석된다. 실제 모드에서는 실릭터의 값은
언제나 패러그래프 수 이였다. 보호 모드에서는 실릭터의 값은 \emph{디스크립터 테이블(descriptor table)} 의 \emph{인덱스(index)} 이다.  
두 모드 모두 프로그램들이 세그먼트 \index{메모리:세그먼트} 들로 나뉘어 진다. 실제 모드에서는 이러한 세그먼트가 물리 메모리에 
고정된 위치에 저장되며 실릭터는 그 세그먼트의 시작 부분의 패러그래프 값을 가리키게 된다. 그러나 보호 모드에서는 세그먼트 들이 물리 메모리에
고정된 위치에 저장되는 것이 아니다. 사실 메모리 상에 존재할 필요도 없다!

보호 모드는 \emph{가상 메모리(virtual memory)} 라는 기술을 이용한다. \index{메모리!가상} 가상 메모리 시스템의 기본적인 개념은
프로그램의 현재 사용하고 있는 데이터와 코드 만 메모리 상에 저장하는 것이다. 다른 데이터나 코드들은 나중에 필요할 때 까지 임시적으로
디스크에 보관하게 된다. 16비트 보호 모드에선 세그먼트들이 메모리와 디스크 사이를 왔다 갔다 하게 되므로 세그먼트들이 언제나 
메모리 상의 고정된 부분을 점유 하고 있을 수 가 없게 된다. 이러한 작업은 운영체에 의해 제어되므로 프로그램이 가상 메모리에서의 작업을
위해 특별히 해 주어야 될 것은 없다. 

보호 모드에서는 개개의 세그먼트가 디스크립터 테이블의 엔트리에 할당되는데 이 디스크립터 테이블에는 시스템이 그 세그먼트에 대해 알아야
할 모든 정보가 수록되어 있다. 예를 들면 현재 메모리 상에 있는지의 유무, 메모리 상에 있다면 어디에 있는지, 접근 가능한지({\em e.g.\/}, 읽기 전용).
세그먼트 엔트리의 인덱스 값이 바로 세그먼트 레지스터에 저장되어 있는 실렉터 값이다. 

16비트 보호 모드의 가장 큰 단점은 오프셋이 아직도 16비트 이라는 점이다. 이 때문에 세그먼트의 크기는 아직도 64KB 로 제한된다. 이는 큰 
배열을 만들기 매우 골치아프게 한다. \MarginNote{한 유명한 PC 칼럼니스트는 286 CPU 를 가리켜 '뇌사 상태' 라고 말했다}

\subsection{32비트 보호 모드}\index{보호 모드!32비트|(}

80386 이 처음으로 32비트 보호 모드의 장을 열었다. 386 32비트와 286 16비트 보호 모드에는 2 개의 큰 차이점이 있는데

\begin{enumerate}
\item

오프셋이 32 비트로 확장되었다. 이는 오프셋의 값이 최대 40억 까지 가능하다는 뜻이다. 따라서, 하나의 세그먼트는 최대 4GB 까지 가질 수 있다. 

\item

세그먼트들은 \index{메모리!세그먼트} 작은 4KB 크기의 \emph{페이지(page)} \index{메모리!페이지} 라 부르는 단위들로 나뉘어 질 수 있다. 
가상 메모리 \index{메모리!가상} 시스템도 세그먼트가 아닌 페이지를 기준으로 작업하게 된다. 이 말은 세그먼트의 일부분도 
메모리에 존재할 수 있게 되었다는 뜻이다. 이전의 286 16 비트 모드에서는 전체 세그먼트가 메모리 상에 한꺼번에 존재하던지, 아니면 메모리 상에 
아무 것도 존재 못하는 2 가지 경우 밖에 없었었다. 이를 거대한 32비트 모드의 세그먼트에 그대로 적용하는 것은 이치에 맞지 않다.  

\end{enumerate}

\index{보호 모드!32비트|)}

윈도우즈 3.x 버전에서 \emph{표준 모드(standard mode)} 는 286 16비트 보호 모드를 가리키고 \emph{향상 모드(enhanced mode)} 는 32 비트 모드
를 가리킨다. 윈도우즈 9X, 윈도우즈 NT/2000/XP, OS/2, 그리고 리눅스에선 모든 프로그램이 페이지 가능한 32비트 보호 모드에서 실행된다. 
% 인터럽트에 대한 정확한 번역이 필요하다. 번역이 약간 stub 하다. 
\subsection{인터럽트\index{인터럽트}}
종종 보통의 프로그램의 흐름이 즉시 응답이 필요한 프로세스 이벤트(event)로 부터 중지되는 경우가 있다. 컴퓨터 하드웨어는 \emph{인터럽트(interrupt)} 라는
메커니즘을 통해 이러한 이벤트를 처리한다. 예를 들어 마우스가 움직였을 때, 마우스 하드웨어는 마우스 움직임을 처리(마우스 커서를 움직
이기 위해) 하기 위해 현재 실행되는 일시적으로 프로그램을 중지시킨다. 인터럽트는 제어 흐름이 \emph{인터럽트 핸들러(interrupt handler)} 을 통과하게
한다. 인터럽트 핸들러는 인터럽트를 처리하는 루틴이다. 각각의 인터럽트는 하나의 정수에 대응이 되어 있다.
물리 메모리 상단에 있는 \emph{인터럽트 벡터 테이블(interrupt vector table)}에 인터럽트 핸들러들의 주소값을 보관한다. 인터럽트의 번호는 본질적으로 테이블의
인덱스가 되는 것이다. 

CPU 외부에서 오는 인터럽트를 외부 인터럽트(External inturrpt) 라 한다. 앞에서 예로 나온 마우스가 외부 인터럽트의 한 예 이다. 대다수의 입출력(I/O) 장치들, 예를 
들어 키보드, 타이머, 디스크 드라이브, CD-ROM, 그리고 사운드 카드 들은 모두 외부 인터럽트를 발생시킨다. 내부 인터럽트는 CPU 내부에서 발생되는 인터럽
트로 오류나 인터럽트 명령에 의해 발생된다. 오류 인터럽트는 \emph{트랩(trap)} 이라고도 불린다. 인터럽트 명령을 통해 발생되는 인터럽트는 
\emph{소프트웨어 인터럽트(software interrupt)} 라 부른다. DOS 는 자체 API(Application Programming Interface) 를 구현하기 위해 이러한 인터럽트를 
사용하였다. 많은 수의 현대 운영체제 (윈도우즈, 유닉스 등등) 에서는 C 기반의 인터페이스(interface) 를 사용한다. 
\footnote{그러나 이들도 커널 수준에서는 저급 수준의 인터페이스를 사용할 것이다.}

많은 인터럽트 핸들러 들은 자신의 역할이 끝나면 중단되었던 프로그램으로 제어 흐름이 돌려진다. 그들은 인터럽트 되기 전에 레지스터에 저장되어 있던
값들을 모두 복원한다. 따라서 중단되었던 프로그램도 마치 아무 일이 없었던 것 처럼 다시 원상태로 실행 될 수 있다.
(다만, 일부 CPU 사이클들을 잃어버렸다) 트랩의 경우 대부분 리턴되지 않으며 종종 프로그램을 종료 시킨다. 

\section{어셈블리어}

\subsection{기계어\index{기계어}}
CPU 들은 자기들 만이 이해할 수 있는 기계어를 가지고 있다. 기계어의 명령들은 메모리에 바이트로 저장되어 있는 숫자들이다. 각 명령들은 자기만의 
유일한 수 코드를 가지고 있고 이것을 \emph{연산 부호(operation code)} 또는 줄여서 \emph{opcode} 라 부른다. 80x86 프로세서 명령의 크기는 
각각 다르며 연산 부호는 언제나 명령 앞 부분에 위치한다. 많은 명령들은 명령에 의해 사용되는 데이터를 포함한다({\em e.g.\/}, 상수나 주소)

기계어는 직접적으로 프로그래밍하기가 매우 힘들다. 수치화 된 각각의 연산 부호들을 해독하는 일이 인간에게는 매우 힘든 일이기 때문이다. 예를 들어, 
EAX 와 EBX 레지스터의 값을 더해 다시 EAX 레지스터에 대입하는 문장은 아래와 같이 기계어로 나타내진다.  

\begin{quote}
   03 C3
\end{quote}
이는 정말로 이해하기 힘들다. 다행이도 \emph{어셈블러(assembler)} \index{어셈블러} 라 불리는 프로그램이 위와 같은 지루한 일을 프로그래머가 안해도 되게
해준다. 

\subsection{어셈블리어}\index{어셈블리어|(}
어셈블리 언어 프로그램은 고급 언어 프로그램 처럼 문자 형태로 저장된다. 각각의 어셈블리 명령들은 하나의 기계 명령에 대응된다. 예를 들어서 위에
예로 든 덧셈 연산은 어셈블리어로 아래와 같이 표현된다.

\begin{CodeQuote}
   add eax, ebx
\end{CodeQuote}
이를 통해 단순히 숫자로 나타낸 기계어 보다 훨씬 알기 쉽게 명령을 나타낼 수 있다.
{\code add} 는 덧셈을 한다라는 명령을 인간이 알기 쉬운 문자열로로 대응 시킨
\emph{연상 기호(mnemonic)} \index{연상 기호} 이다. 어셈블리어의 일반적인 형식은 아래와 같다

\begin{CodeQuote}
  {\em mnemonic operand(s)}
\end{CodeQuote}

\emph{어셈블러(assembler)} \index{어셈블러} 는 어셈블리 명령들로 작성된 파일을 읽어 들어서 기계어로 작성된 코드로 변환해 주는 프로그램이다. 
\emph{컴파일러(Compiler)} \index{컴파일러} 는 위와 비슷한 작업을 하지만 다만 고급 언어로 작성된 코드를 기계어로 변환해 준다.
\MarginNote{컴퓨터 과학자들은 컴파일러 자체를 어떻게 작성할지에 대해 수년간 연구하였다! } 모든 어셈블리 문장은 하나의 기계어 문장을 직접
적으로 나타낸다. 한편 고급 언어의 경우 하나의 문장이 \emph{훨씬} 많고 복잡한 기계 명령을 나타낸다. 

어셈블리어와 고급언어의 또다른 차이점은 모든 CPU 가 각각의 고유한 기계어를 가지고 있고 또 고유의 어셈블리어를 가지고 있다는 점이다. 다른 컴퓨터 아키텍쳐
에 어셈블리 프로그램을 포팅(porting) 하는 이는 고급 언어에서 처리하는 것 보다 훨씬 어려운 일이다. 

이 책에서는 예제들은 Netwide Assembler 또는 NASM \index{NASM} 이라 불리는 어셈블리어를 사용할 것이다. 이는 인터넷에서 무료로 받을 수 있다. 
(머리말 참조)
다른 어셈블러들로는 마이크로소프트 사의 MASM \index{MASM} 이나 볼랜드 사의 TASM \index{TASM} 을 들 수 있다. NASM 과 MASM/TASM 의 
문법은 약간 다르다. 

\subsection{피연산자}

기계 코드 명령들에 따라 피연산자의 형태와 개수가 다르다. 그러나 대부분 각각의 명령들은 고정된 수의 피연산자 수(보통 0 - 3)를 갖는다. 
피연산자로 올 수 있는 것들은 아래와 같다.

\begin{description}
\item[레지스터:]
이 피연산자들은 CPU 레지스터들에 직접적으로 접근할 수 있다. 

\item[메모리:]
이는 메모리에 저장된 데이터를 가리킨다. 이 때, 메모리의 주소값은 명령에 직접적으로 사용하거나, 레지스터에 저장하여 사용할 수도 있다.
언제나 세그먼트 최상단 부터의 오프셋 값으로 나타낸다. 

\item[즉시 피연산자:]
\index{즉시 피연산자}
즉시 피연산자(immediate) 는 명령 자체에 있는 고정된 값들이다. 이들은 명령 자체에 저장된다(즉, 데이터 세그먼트가 아닌 코드 세그먼트에 저장됨)

\item[묵시적 피연산자:]
묵시적 피연산자(implied) 는 정확히 나타나지 않는다. 예를 들어서 증가 명령은 레지스터나 메모리에 1 을 더한다. 이 때 1 을 묵시적 피연산자 라고 부른다. 
\end{description}
\index{어셈블리어|)}

\subsection{기초 명령}

어셈블리어에서 가장 기본이 되는 명령은 {\code MOV} \index{MOV} 명령이다. 이는 특정한 지점의 데이터를 다른 지점으로 이동시킨다. (이는 고급 언어의
대입 연산자와 같다) 이 명령은 두 개의 피연산자를 필요로 한다
\begin{CodeQuote}
  mov {\em dest, src}
\end{CodeQuote}
{\em src} 에 있는 데이터가 {\em dest\/} 로 복사된다. 이 때, 두 피연산자가 모두 메모리이면 안된다. 이는 어셈블리어의 한 가지 흠
이라 볼 수 있다. 어셈블리에서는 명령문에 따라 특정한 기준 없이 규칙이 달라지는 경우가 있다. 두 개의 피연산자의 크기가 같아야 한다. 
예를 들어 AX (16 비트)에 있는 값은 BL (8비트) 로 저장될 수 없다. 

여기 예제가 있다. (세미 콜론은 주석의 시작을 나타낸다\index{주석}):

\begin{AsmCodeListing}[frame=none, numbers=none]
      mov    eax, 3   ; eax 레지스터에 3 을 대입한다 (이 때 3 은 즉시 피연산자 이다)
      mov    bx, ax   ; ax 레지스터의 값을 bx 레지스터에 대입한다.
\end{AsmCodeListing}

{\code ADD} \index{ADD} 명령은 두 개의 정수를 더할 때 사용된다.

\begin{AsmCodeListing}[frame=none, numbers=none]
      add    eax, 4   ; eax = eax + 4
      add    al, ah   ; al = al + ah 
\end{AsmCodeListing}

{\code SUB} \index{SUB} 명려은 한 정수에서 다른 정수를 뺄 때 사용된다.

\begin{AsmCodeListing}[frame=none, numbers=none]
      sub    bx, 10   ; bx = bx - 10
      sub    ebx, edi ; ebx = ebx - edi
\end{AsmCodeListing}

{\code INC} \index{INC} 와 {\code DEC} \index{DEC} 는 1 을 증가 또는 감소 시키는 명령이다. 1 이 묵시적 피연산자이므로 {\code INC} 와 {\code DEC} 의
기계 코드는 동일한 작업을 수행하는 {\code ADD} 와 {\code SUB} 의 기계 코드의 크기 보다 작다. 

\begin{AsmCodeListing}[frame=none, numbers=none]
      inc    ecx      ; ecx++
      dec    dl       ; dl--
\end{AsmCodeListing}

\subsection{지시어\index{지시어|(}}

\emph{지시어(directive)} 는 CPU 가 아닌 어셈블러를 위해 만들어 진 것이다. 이것들은 주로 어셈블러로 하여금 무언가를 하게 하거나 아니면
어셈블러에게 무언가를 알려주는 역할을 한다. 지시어는 기계 코드로 변환되지 않는다. 지시어들의 주 용도로는:

\begin{list}{$\bullet$}{\setlength{\itemsep}{0pt}}
\item  상수를 정의한다
\item 데이터를 저장할 메모리를 정의한다
\item 메모리를 세그먼드로 묶는다
\item 조건적으로 소스 코드를 포함시킨다
\item 다른 파일들을 포함시킨다.
\end{list}

NASM 은 C 와 비슷한 전처리기 명령들이 있다. 그러나 NASM 의 전처리기 지시어는 C 에서의 \# 이 아닌 \% 을 사용한다. 

\subsubsection{equ 지시어\index{지시어!equ}}

{\code equ} 지시어는 \emph{심볼(symbol)} 을 정의할 때 사용된다. 심볼은 어셈블리 프로그래밍시 사용되는 상수를 뜻한다. 이는 아래와 같이 사용한다

\begin{quote}
  \code {\em symbol} equ {\em value}
\end{quote}

한 번 정의된 심볼의 값은 \emph{절대로} 재정의 될 수 없다. 

\subsubsection{The \% 정의 지시어\index{지시어!\%정의}}

이 지시어는 C 에서의 {\code \#define} 지시어와 비슷하다. 이는 C 에서 처럼 상수 매크로를 정의할 때 사용된다
\begin{AsmCodeListing}[frame=none, numbers=none]
%define SIZE 100
      mov    eax, SIZE
\end{AsmCodeListing}

위의 나온 코드는 {\code SIZE} 라는 이름의 매크로를 정의하고 이를 {\code MOV} 명령에서 어떻게 사용하는지 보여주고 있다. 매크로는 심볼들 보다 좀 더 
유연한다. 왜냐하면 매크로는 심볼들과는 다르게 재정의 될 수 있고 단순한 수가 아니여도 되기 때문이다. 

\subsubsection{데이터 지시어\index{지시어!데이터|(}}

\begin{table}[t]
\centering
\begin{tabular}{||c|c||} \hline
{\bf Unit} & {\bf Letter} \\
\hline
바이트 & B \\
워드& W \\
더블워드 & D \\
쿼드워드 & Q \\
10 바이트 & T \\
\hline
\end{tabular}
\caption{{\code RESX} 와 {\code DX} 지시어를 위한 글자 
         \label{tab:size-letters} }
\end{table}

데이터 지시어들은 데이터 세그먼트에서 메모리 상의 공간을 정의하는데 사용된다. 메모리 공간이 정의되는데에는 2 가지 방법이 있다. 첫 번째 방법은
오직 데이터를 위한 공간들만 정의한다. 두 번째 방법은 초기의 값들을 위한 방들을 정의한다. 첫 번째 방법의 경우 {\code RES{\em
X}}\index{지시어!RES\emph{X}} 지시어를 사용한다. {\em X} 에는 저장될 데이터의 크기를 나타내는 문자가 들어간다. 이는 표~\ref{tab:size-letters}를
참조하여라. 

두 번째 방법(초기값도 정의하는) 은 {\code D{\em X}} 지시어\index{지시어!D\emph{X}} 를 사용한다. {\em X} 에는 역시 {\code RES{\em X}} 지시어
사용시 들어가는 문자가 들어가게 된다. 

메모리 위치를 \emph{라벨(label)} 로 표시하는 것은 매우 흔한 일이다. \index{라벨} 라벨은 코드 상에서 특정한 메모리 위치를 가리킬 수 있다. 아래 
예제를 참조하면 :

\begin{AsmCodeListing}[frame=none, numbers=none]
L1    db     0        ; L1 로 라벨 붙혀진 바이트가 0 으로 초기화 됨
L2    dw     1000     ; L2 로 라벨 붙혀진 워드가 1000 으로 초기화 됨
L3    db     110101b  ; L3 로 라벨 붙혀진 바이트가 이진수 110101(십진수로 53)로 초기화 됨
L4    db     12h      ; L4 로 라벨 붙혀진 바이트가 16진수 12 로 초기화 됨
L5    db     17o      ; L5 로 라벨 붙혀진 바이트가 8진수 17 로 초기화됨
L6    dd     1A92h    ; L6 로 라벨 붙혀진 더블워드가 16진수 1A92 로 초기화 됨
L7    resb   1        ; L7 로 라벨 붙혀진 초기화 되지 않은 1 바이트
L8    db     "A"      ; L8 로 라벨 붙혀진 아스키 코드 A(65) 로 초기화 됨
\end{AsmCodeListing}

큰따옴표와 작은따옴표는 모두 같은 것으로 취급된다. 데이터가 연속적으로 정의되면 그 데이터들은 메모리 상에 연속되게 존재하게 된다. 
따라서, 메모리 상에서 L2 는 L1 바로 다음으로 위치하게 된다. 메모리 상에서의 순서 또한 정의 될 수 있다. 

\begin{AsmCodeListing}[frame=none, numbers=none]
L9    db     0, 1, 2, 3              ; 4 바이트를 정의한다
L10   db     "w", "o", "r", 'd', 0   ; C 문자열 "word" 를 정의한다
L11   db     'word', 0               ; L10 과 같다
\end{AsmCodeListing}

{\code DD} \index{지시어!DD} 지시어는 정수와 단일 정밀도 부동 소수점 \footnote{단일정밀도 부동 소수점은 C 언어의 {\code float} 와 같다} 상수들을 
정의할 수 있다. 그러나 {\code DQ}\index{지시어!DQ} 의 경우 오직 2배 정밀도 부동 소수점 상수만 정의할 수 있다.

크기가 큰 것들을 위해선 NASM 의 {\code TIMES} \index{지시어!TIMES} 지시어를 이용하면 된다. 이 지시어는 피연산자를 특정한 횟수 만큼 반복한다. 
예를 들면

\begin{AsmCodeListing}[frame=none, numbers=none]
L12   times 100 db 0                 ; 이는 100 개의 (db 0) 을 나열하는 것과 같다
L13   resw   100                     ; 100 개의 워드를 위한 공간을 정의한다.
\end{AsmCodeListing}
\index{지시어!데이터|)}
\index{지시어|)}

\index{라벨|(}
아까 라벨이 코드 상의 데이터를 가리키는데 쓰인다는 말을 상기해보자. 라벨이 사용되는 용도는 2 가지가 있다. 만약 라벨을 그냥 이용한다면
이는 데이터의 주소 (즉, 오프셋) 으로 생각된다. 만약 라벨이 대괄호({\code []}) 속에 사용된다면 이는 그 주소에 위치한 데이터를 나타낸다. 
다시 말해 라벨을 어떤 데이터에 대한 \emph{포인터(pointer)} 라 하면 대괄호는 C 언어의 \* 와 같은 역할을 하는 것이다. 
(MASM/TASM 에서는 다른 방법을 사용한다) 32비트 모드에서는 주소들의 크기는 32비트 이다. 아래 예제를 보면: 

\begin{AsmCodeListing}[frame=none]
      mov    al, [L1]      ; AL 에 L1 에 위치한 데이터를 대입한다.
      mov    eax, L1       ; EAX = L1 에 위치한 바이트의 주소 
      mov    [L1], ah      ; L1 에 위치한 바이트에 ah 를 대입한다
      mov    eax, [L6]     ; L6 에 위치한 더블워드를 EAX 에 대입한다
      add    eax, [L6]     ; EAX = EAX + L6 에 위치한 더블워드
      add    [L6], eax     ; L6 에 위치한 더블워드 += EAX
      mov    al, [L6]      ; L6 에 위치한 더블워드의 하위 비트를 AL 에 대입한다 
\end{AsmCodeListing}
7 번째 행을 보면 NASM 의 중요한 특징을 알 수 있다. 어셈블러는 라벨이 어떠한 데이터를 가리키고 있는지 \emph{전혀} 신경쓰지 않는다. 이는 모두
프로그래머에 달려 있기에 언제나 라벨을 정확히 사용하는데 신중을 기해야 할 것이다. 나중에 데이터의 주소값을 레지스터에 저장하여 C 언어의
포인터 처럼 쓰는 연산을 많이 하게 된다. 이 때도 이 포인터가 정확하게 사용되고 있는지에 대해선 어셈블러가 전혀 신경쓰지 않는다. 이 때문에
어셈블리를 이용한 프로그래밍은 C 보다도 오류가 잦아지게 된다. 

다음과 같은 명령을 고려하자.
\begin{AsmCodeListing}[frame=none, numbers=none]
      mov    [L6], 1             ; L6 에 위치한 데이터에 1 을 저장한다
\end{AsmCodeListing}

위 문장은 {\code 명령의 크기가 정의되지 않았습니다} 라는 오류를 발생한다. 왜? 왜냐하면 어셈블러가 1 을 바이트로 저장할지, 워드로 저장할지, 
더블워드로 저장할지 모르기 때문이다. 이 문제를 해결하기 위해선 아래와 같이 해주면 된다. 

\begin{AsmCodeListing}[frame=none, numbers=none]
      mov    dword [L6], 1       ; L6 에 1 을 저장한다
\end{AsmCodeListing}
\index{DWORD}
이를 통해 어셈블러는 1 을 메모리 상의 {\code L6} 에서 시작하는 부분 부터 더블워드로 저장하라는 것을 알 수 있다. 그 외에도 {\code BYTE}\index{BYTE}, 
{\code WORD}\index{WORD}, {\code QWORD}\index{QWORD}, {\code TWORD}\footnote{{\code TWORD} 는 메모리 상의 10 바이트를 정의한다
부동 소수점 보조 프로세서가 이 데이타 형식을 사용한다.}\index{TWORD} 가 있다.
\index{라벨|)}

\subsection{입출력 \index{I/O|(}}

입출력(I/O)은 매우 시스템 종속적인 작업들이다. 이는 컴퓨터 시스템의 하드웨어와의 소통을 필요로 한다. C 와 같은 고급 언어에선 I/O 를 위한 표준 라이브러리
를 제공한다. 어셈블리 언어에서는 C 와 같은 라이브러리가 제공되지 않는다. 따라서, 어셈블리에선 직접적으로 하드웨어에 접근하거나
(이는 보호 모드에서 특별한 권한을 가지는 작업이기도 한다) 운영체제가 제공하는 저수준의 루틴들을 사용해야 한다. 

\index{I/O!어셈블리 I/O 라이브러리|(} 
어셈블리 루틴과 함께 C 언어를 사용하는 것은 매우 흔한 일이다. 왜냐하면 어셈블리 코드가 표준 C 입출력 라이브러리 루틴을 사용할 수 있기 때문이다.
그러나, C 가 사용하는 루틴에게 정보를 전달하는데에는 규칙이 있다는 점을 알아야 한다. 그 규칙들을 여기서 직접 다루기에는 복잡하다 (나중에 다룰 것이다).
저자는 입출력을 단순화 하기 위해 복잡한 C 규칙을 숨기고 훨씬 간단한 인터페이스를 이용하는 루틴을 제공한다. 표 ~\ref{tab:asmio} 에 
저자가 개발한 루틴들에 대해 설명하고 있다. 읽기 루틴만을 제외한 모든 루틴들은 모든 레지스터의 값을 저장한다. 이 루틴들을 이용하기 위해서는 이
루틴들에 대한 정보가 기록된 파일들을 소스에 포함시켜 어셈블러가 사용할 수 있게 해야 한다. NASM 에서 파일을 포함하기 위해선 {\code \%include} 전처리기
지시어를 사용하면 된다. 저자가 만든 I/O 루틴을 \footnote{ {\code asm\_io.inc} (그리고  {\code asm\_io.inc}  가 필요로 하는 {\code asm\_io} 파일) 은 이
책의 웹 페이지인 {\code http://www.drpaulcarter.com/pcasm} 에서 다운로드가 가능하다} NASM 에 포함 시키기 위해서는 아래와 같이 하면 된다.

\begin{AsmCodeListing}[frame=none, numbers=none]
%include "asm_io.inc"
\end{AsmCodeListing}

\begin{table}[t]
\centering
\begin{tabular}{lp{3.5in}}
{\bf print\_int} & EAX 에 저장된 값을 화면에 출력한다.  
                   \\
{\bf print\_char} & AL 에 저장된 아스키 코드 값에 대응
                    하는 문자를 화면에 표시한다 \\
{\bf print\_string} & EAX 에 저장된 문자열의 {\em 주소값} 에 해당하는
                     문자열을 화면에 출력한다. 문자열은 반드시 C 형식
                     이어야 한다({\em i.e.} null 로 종료). \\
{\bf print\_nl} & 화면에 개행문자를 출력한다. \\
{\bf read\_int} & 키보드로 부터 정수를 입력받은 다음 EAX 
                 레지스터에 저장한다. \\
{\bf read\_char} & 키보드로 부터 한 개의 문자를 입력 받은 후
                  그 문자의 아스키코드값을 EAX 레지스터에 저장한다. \\
\end{tabular}
\caption{어셈블리 I/O 루틴 \label{tab:asmio} \index{I/O!asm\_io library!print\_int}
\index{I/O!asm\_io library!print\_char} \index{I/O!asm\_io library!print\_string} 
\index{I/O!asm\_io library!print\_nl} \index{I/O!asm\_io library!read\_int}
\index{I/O!asm\_io library!read\_char}}
\end{table}

위 I/O 루틴 중 출력 루틴을 사용하고 싶다면 EAX 레지스터에 적당한 값을 대입하고 {\code CALL} 명령을 사용해 호출한다. {\code CALL} 명령은 고급 언어에서의
함수를 호출하는 것과 동일하다. 이 명령 사용시 코드의 다른 부분으로 실행을 분기했다가 그 루틴이 종료된다면 다시 원래 호출했던 부분으로 돌아오게(리턴)
된다. 아래의 예제 프로그램은 이러한 I/O 루틴의 호출을 보여준다. 

\subsection{디버깅\index{디버깅|(}}
저자의 라이브러리는 프로그램을 디버깅하는데 유용한 루틴들을 포함하고 있다. 이 디버깅 루틴은 컴퓨터의 상태를 변경하지 않고서 화면에 그대로 상태를 
출력하게 해준다. 이 루틴들을 CPU 의 현 상태를 저장하고 서브 루틴을 호출하는 \emph{매크로} 이다. 이 매크로들은 {\code asm\_io.inc} 파일에 정의되어 
있다. 매크로들은 보통 명령들 처럼 사용된다. 이 때 매크로들의 피연산자 들은 반점(,)을 통해 구분한다. 

저자의 라이브러리에는 4 개의 디버깅 루틴이 있는데 이는 각각 {\code dump\_regs}, {\code
dump\_mem}, {\code dump\_stack}, {\code dump\_math} 이다. 이 들은 레지스터, 메모리, 스택, 그리고 수학 보조프로세서에 들어있는 값들을 모두 보여준다

\begin{description}

\item[dump\_regs]
\index{I/O!asm\_io library!dump\_regs} 
이 매크로는 레지스터에 들어있는 값들을 화면에({\code stdout}) 16진수로 출력한다. 또한 플래그 레지스터의  비트 세트\footnote{Chapter~2 에서 다룰 것이다} 
를 화면에 출력한다. 예를 들어서 제로 플래그가 1 이라면 \emph{ZF} 가 화면에 출력된다. 0 이라면 화면에 출력되지 않는다. 이 매크로는 한 개의 정수를 인자로
가지는데 이를 통해 서로 다른 {\code dump\_regs} 명령의 출력들을 구분 할 수 있게 한다. 

\item[dump\_mem]
\index{I/O!asm\_io library!dump\_mem} 
이 매크로는 메모리의 일부 영역의 값들을 16 진수나 아스키 문자로 출력한다. 이 매크로는 반점으로 구분되는 3 개의 매개 변수를 가진다.
첫 번째는 {\code dump\_regs} 매크로 처럼 출력을 구분하기 위한 정수, 두 번째는 출력하기 위한 메모리의 주소, 마지막은 주소 뒤에 출력될 16 바이트 
패러그래프의 수 이다.  요청된 메모리 주소 이전의 패러그래프 경계 부터 메모리 값들이 출력 될 것이다. 

\item[dump\_stack]
\index{I/O!asm\_io library!dump\_stack} 
이 매크로는 CPU 의 스택에 저장된 값들을 출력한다. (스택에 대해서는 Chapter~4 에서 다룰 것이다) 스택은 더블워드로 구성되어 있으며 이 매크로를 통해
스택에 들어 있는 값들을 출력할 수 있다. 3 개의 반점으로 구분되는 인자를 가지며 첫 번째는 {\code dump\_regs} 에서 처럼 출력을 구분하기 위한 정수, 두 번째는 
{\code EBP} 레지스터에 저장된 주소 \emph{아래} 부터 출력할 더블워드의 수, 세 번째는 {\code EBP} 레지스터 주소 \emph{위}로 출력할 더블워드의 수 이다. 

\item[dump\_math]
\index{I/O!asm\_io library!dump\_math} 
이는 수치 부프로세서의 레지스터에 저장되어 있는 값들을 출력한다. {\code dump\_regs} 에서 처럼 결과를 구분 하기 위한 정수를 매개 변수로 입력받는다.
\end{description}
\index{디버깅|)}
\index{I/O!asm\_io library|)} 
\index{I/O|)}

\section{프로그램 만들기}

요즘에는 어셈블리어 언어만을 이용하여 프로그램을 만드는 것은 흔치 않은 일이다. 어셈블리는 오직 중요한 일부 루틴에서만 이용하게 된다. 왜냐하면, 어셈블러
언어 보다 고급 언어로 작성하는 일이 \emph{훨씬} 편하기 때문이다. 또한 어셈블리 언어를 이용시 프로그램을 다른 플랫폼에 프로그램을 포팅하는 작업이 매우
어렵게 된다. 사실상, 어셈블리어를 사용하는 일은 드물다. 

하지만 우리는 왜 어셈블리 언어를 배워야 하는가?

\begin{enumerate}
\item 때때로 컴파일러가 생성한 코드 보다 어셈블리어로 직접 쓴 코드가 훨씬 
      빠르고 작을 수 있다. 
\item 어셈블리어를 통해 고급언어 사용시 힘들거나 불가능한 시스템 하드웨어의
      직접적인 접근을 할 수 있다. 
\item 어셈블리 언어를 공부함을 통해서 컴퓨터의 작동 원리를 깊게 파악 할 수 있다. 
      
\item 어셈블리 언어를 공부함을 통해 컴파일러와 C 와 같은 고급 언어가 어떻게
      동작하는지 파악하는데 도움이 된다.
\end{enumerate}
특히 마지막 두 가지 이유를 보면 우리는 어셈블리로 직접 프로그래밍을 하지 않아도 많은 도움을 받을 수 있다는 사실을 알 수 있다. 사실 저자인 나도 어셈블리어
만으로는 거의 프로그램을 짜지 않지만 어셈블리에서 얻은 아이디어를 매일 사용하고 있다. 

\subsection{첫 프로그램}

\begin{figure}[t]
\begin{lstlisting}[frame=tlrb]{}
int main()
{
  int ret_status;
  ret_status = asm_main();
  return ret_status;
}
\end{lstlisting}
\caption{{\code driver.c} 코드\label{fig:driverProg} \index{C driver}}
\end{figure}
우리가 처음에 작성할 프로그램들은 그림 ~\ref{fig:driverProg} 와 같은 단순한 C 드라이버 프로그램 들이다. 이는 단순히 {\code asm\_main}  함수
만을 호출한다. 이 루틴은 우리가 나중에 어셈블리로 쓸 것이다. C 드라이버 루틴을 이용하면 몇 가지 장점들이 있다. 첫 번째로 C 시스템은 보호 모드에서 프로그램이
잘 돌아가도록 모든 것을 설정해 준다. C 에 의해 모든 세그먼트와 이에 대응 되는 세그먼트 레지스터들은 초기화 된다. 어셈블리에서도 걱정할 필요는
없다. 두 번째로 어셈블리 코드를 사용하여 C 라이브러리를 사용할 수 있다. 저자의 I/O 루틴이 이 사실을 이용한다. 이들은 C 의 I/O 함수를 사용한다 (
{\code printf} 등등) 아래에는 간단한 어셈블리 프로그램을 소개했다. 

\begin{AsmCodeListing}[label=first.asm]
; file: first.asm
; 최초의 어셈블리 프로그램. 이 프로그램은 2 개의 정수를 입력받아
; 그 합을 출력한다. 
;
; 실행 가능한 프로그램을 만들려면 DJGPP 를 이용해라 : 
; nasm -f coff first.asm
; gcc -o first first.o driver.c asm_io.o

%include "asm_io.inc"
;
; 초기화 된 데이터는 .data 세그먼트에 들어간다.

segment .data
;
; 아래 라벨들은 출력을 위한 문자열들을 가리킨다. 
;
prompt1 db    "Enter a number: ", 0       ; 널 종료 문자임을 잊지 말라!
prompt2 db    "Enter another number: ", 0
outmsg1 db    "You entered ", 0
outmsg2 db    " and ", 0
outmsg3 db    ", the sum of these is ", 0

;
; 초기화 되지 않은 데이터는 .bss 세그먼트에 들어간다. 
;
segment .bss
;
; 이 라벨들은 입력 값들을 저장하기 위한 더블워드를 가리킨다. 
input1  resd 1
input2  resd 1

;
; 코드는 .text 세그먼트에 들어간다.
;
segment .text
        global  _asm_main
_asm_main:
        enter   0,0               ; 셋업(set up) 루틴
        pusha

        mov     eax, prompt1      ; prompt 를 출력
        call    print_string

        call    read_int          ; 정수를 읽는다. 
        mov     [input1], eax     ; input1 에 저장.

        mov     eax, prompt2      ; prompt 를 출력
        call    print_string

        call    read_int          ; 정수를 읽는다. 
        mov     [input2], eax     ; input2 에 저장. 

        mov     eax, [input1]     ; eax = input1 에 위치한 dword
        add     eax, [input2]     ; eax += input2 에 위치한 dword
        mov     ebx, eax          ; ebx = eax

        dump_regs 1                ; 레지스터의 값을 출력
        dump_mem  2, outmsg1, 1    ; 메모리를 출력
;
; 아래 단계별로 메세지를 출력한다. 
;
        mov     eax, outmsg1
        call    print_string      ; 첫 번째 메세지를 출력
        mov     eax, [input1]     
        call    print_int         ; input1 을 출력
        mov     eax, outmsg2
        call    print_string      ; 두 번째 메세지를 출력
        mov     eax, [input2]
        call    print_int         ; input2 를 출력
        mov     eax, outmsg3
        call    print_string      ; 세 번째 메세지를 출력
        mov     eax, ebx
        call    print_int         ; 합을 출력 (ebx)
        call    print_nl          ; 개행문자를 출력

        popa
        mov     eax, 0            ; C 로 리턴된다. 
        leave                     
        ret
\end{AsmCodeListing}

~13 행에서 프로그램의 데이터 세그먼트({\code .data})\index{데이터 세그먼트}에 저장될 메모리 공간을 정의하였다. 이 세그먼트에는 오직 초기화 된 데이터 만이
올 수 있다. ~17 에서 21 행에서는 몇 개의 문자열들이 선언되었다. 이들은 C 라이브러리를 통해 출력되기 때문에 반드시 \emph{널(NULL)} 문자로 끝마쳐져야 한다
(아스키 코드 값이 0). 참고로 {\code 0} 과 {\code '0'} 에는 매우 큰 차이가 있다는 사실을 알아두라. 

초기화 되지 않은 데이터는 반드시 bss 세그먼트({\code .bss}) 에서 선언되어야 한다. 이 세그먼트는 초기 유닉스 기반의 어셈블러에서 사용된 ``심볼을 통해
시작된 블록(block started by symbol)." 연산자의 이름에서 따온 것이다. 이것에 대해선 나중에 다루겠다.  

코드 세그먼트\index{코드 세그먼트}는 역사적으로 {\code .text} 라 불려왔다. 이는 명령어들이 저장되는 곳이다. (~38 행) 의 메인 루틴의 라벨에 접두어 \_ (under
score)가 사용되었음을 유의하자. 이는 \emph{C 함수 호출 규약(C calling convention)} \index{호출 규약!C} 의 일부분이다. 이 규약은 코드 컴파일 시에 C 가
사용하는 규칙들을 명시해 준다. 이는  어셈블리어와 C 를 같이 사용시에 이 호출 규약을 아는 것이 매우 중요하다. 나중에 이 호출 규약에 대해 속속 살펴 볼 것이다.
그러나, 지금은 오직 모든 C 심볼들 ({\em i.e.}, 함수와 전역 변수) 에는 C 컴파일러에 의해 \_ 가 맨 앞에 붙는 다는 사실만 알면 된다. (이 규칙은 오직 DOS/Windows
에만 해당하며 리눅스 C 컴파일러에서는 C 심볼 이름에 아무것도 붙이지 않는다) 

37 행의 {\code global}{\index{지시어!전역}} 지시어는 어셈블러로 하여금 {\code \_asm\_main} 라벨을 전역으로 생성하라고 알려준다. C 에서와는 달리 라벨들은
\emph{내부 지역(internal scope)}이 기본으로 된다. 이 뜻은 오직 같은 모듈에서만 그 라벨을 사용할 수 있다는 뜻이다. 하지만 \emph {전역(global)} 지시어를 이용하면 
라벨을 \emph {외부 지역(external scope)} 에서도 사용할 수 있게 된다. 이러한 형식의 라벨은 프로그램의 어떠한 다른 모듈에서도 접근이 가능하다. {\code asm\_io}
모듈은 {\code print\_int} 등을 모두 전역으로 선언한다. 이 때문에 우리가 {\code first.asm} 모듈에서 이를 사용할 수 있었다. 

\subsection{컴파일러 의존성}

위에 나온 어셈블리 코드는 오직 무료 GNU\footnote{무료 소프트웨어 재단(Free Software Foundation)} 의 DJGPP \index{컴파일러!DJGPP} C/C++ 컴파일러
에서만 돌아간다\footnote{\code http://www.delorie.com/djgpp} 이 컴파일러는 인터넷을 통해 무료로 다운로드 할 수 있다. 이 컴파일러는 386 이상의 
PC 를 필요로 하며, DOS 나 Windows 95/98, NT 등에서 잘 실행된다. 이 컴파일러는 COFF(Common Object File Forma) 형식의 목적 파일(Object File) 을 
이용한다. 이 형식으로 어셈블하기 위해서는 {\code nasm} 과 함께 {\code -f~coff} 스위치를 사용해야 한다. (위 소스코드 주석이 잘 나와 있다) 
생성되는 목적 파일의 확장자는 {\code o} 가 된다. 

리눅스 C 컴파일러 또한 GNU 컴파일러이다. \index{컴파일러!gcc} 위 코드를 리눅스에서 실행되게 바꾸려면 단순히 ~37 에서 38 행의 \_ 를 지워주기만
하면 된다. 리눅스에서 목적파일은 ELF(링크 및 실행 가능한 포맷, Excutable and Linkable Format) 형식을 이용한다. 리눅스에선 {\code -f~elf} 스위치를
이용하면 된다. 또한 목적파일의 확장자는 {\code o} 이다 . \MarginNote{이 컴파일러를 위한 예제 파일들은 저자의 홈페이지에서 다운 받을 수 
있다. }

볼랜드 C/C++ \index{컴파일러!볼랜드} 는 또다른 유명한 컴파일러이다. 이는 목적파일을 마이크로소프트의 OMF 형식을 이용한다. 볼랜드사 컴파일러를
위해선 {\code -f~obj} 스위치를 이용하면 된다. OMF 형식은 다른 목적 파일 포맷들과는 달리 다른 \emph{세그먼트} 지시어를 사용한다.  ~13 행의 데이터
세그먼트는 아래와 같이 바뀌어야 한다. 목적 파일의 확장자는 {\code obj} 이다.

\begin{CodeQuote}
segment \_DATA public align=4 class=DATA use32
\end{CodeQuote}
26 행의 bss 세그먼트는 아래와 같이 바뀐다:
\begin{CodeQuote}
segment \_BSS public align=4 class=BSS use32
\end{CodeQuote}
36행의 텍스트 세그먼트는 아래와 같이 바뀐다. 
\begin{CodeQuote}
segment \_TEXT public align=1 class=CODE use32
\end{CodeQuote}
뿐만 아니라 36 행에 아래와 같은 새로운 행이 덧붙여져야 한다. 
\begin{CodeQuote}
group DGROUP \_BSS \_DATA
\end{CodeQuote}

마이크로소프트 C/C++ \index{컴파일러!마이크로소프트} 컴파일러는 목적 파일으로 OMF 나 Win32 형식을 이용할 수 있다. (OMF 형식을 이용한다 해도
그 정보를 내부적으로는 Win32 로 바꾸어서 처리한다) Win32 형식을 이용하면 DJGPP 나 리눅스에서 처럼 세그먼트를 정의할 수 있다. {\code -f~win32} 스위치
를 통해 위 모드로 출력할 수 있다. 목적 파일의 확장자는 {\code obj} 가 된다. 

\subsection{코드를 어셈블 하기}

커맨드 라인에 아래와 같이 입력한다.

\begin{CodeQuote}
nasm -f {\em object-format} first.asm
\end{CodeQuote}
이 때, {\em object-format} 부분에는 {\em coff\/}, {\em elf\/}, {\em obj}, {\em win32} 중 하나가 올 수 있으며 사용할 C 컴파일러에 따라 달라진다. 
(물론 리눅스나 볼랜드나에 따라서도 소스파일의 내용이 바뀌어야 함을 잊지 말아야한다)

\subsection{C 코드를 컴파일 하기}

DJGPP 를 사용한다면:
\begin{CodeQuote}
gcc -c driver.c
\end{CodeQuote}
{\code -c} 스위치는 단지 컴파일 만을 하란 뜻이다. 아직 링크는 하지 않는다. 리눅스나 볼랜드, 마이크로소프트 컴파일러도 동일한 스위치를 사용한다. 

\subsection{목적 파일 링크하기 \label{seq:linking} \index{링킹|(}}

링킹은 기계어 코드와 목적 파일과 라이브러리 파일에 들어있는 데이터를 하나로 합쳐서 실행가능한 파일을 만드는 과정이다. 아래에 나타나있듯이 
이 과정은 복잡한다. 

C 코드는 표준 C 라이브러리와 특별한 \emph{개시 코드(startup code)}\index{개시 코드} 를 필요로 한다. 이는 C 컴파일러가 정확한 매개 변수와 함께 링커를 호출
하고 직접적으로 링커를 호출하는 작업을 훨씬 쉽게 하게 해준다. 예를 들어서 위 프로그램을 DJGPP 으로 링크 할 때, \index{컴파일러!DJGPP}

\begin{CodeQuote}
gcc -o first driver.o first.o asm\_io.o
\end{CodeQuote}
를 쓰면 {\code first.exe} (리눅스에선 그냥 {\code first}) 라는 실행 가능한 파일이 만들어 진다. 

볼랜드 컴파일러 \index{컴파일러!볼랜드} 는 
\begin{CodeQuote}
bcc32 first.obj driver.obj asm\_io.obj
\end{CodeQuote}
와 같이 하면 된다. 볼랜드는 실행 가능한 파일의 이름을 정할 때 나열된 첫 번째 파일의 이름을 따오게 된다. 따라서, 위 경우 프로그램의 이름은 {\code first.exe} 
가 된다. 

컴파일과 링크 과정을 하나로 같이 묶어서 할 수 도 있다. 예를 들어서 
\begin{CodeQuote}
gcc -o first {\em driver.c} first.o asm\_io.o
\end{CodeQuote}
그러면 {\code gcc} 는 {\code driver.c} 를 컴파일 한 후 링크할 것이다. 
\index{링킹|)}

\subsection{어셈블리 리스트 파일 이해 \index{listing file|(}}

{\code -l {\em listing-file}} 스위치는 {\code nasm} 으로 하여금 주어진 이름의 리스트 파일을 생성하라고 명령한다. 
이 파일은 코드가 어떻게 어셈블 되었는지 보여준다.
아래 ~17 에서 18 행 (데이타 세그먼트) 이 리스트 파일에 어떻게 나타났는지 보여준다. (리스트 파일의 행 번호를 잘 보면 실제 소스 파일의 행 번호와 다름을 
알 수 있다) 

\begin{Verbatim}[xleftmargin=\AsmMargin]
48 00000000 456E7465722061206E-     prompt1 db    "Enter a number: ", 0
49 00000009 756D6265723A2000
50 00000011 456E74657220616E6F-     prompt2 db    "Enter another number: ", 0
51 0000001A 74686572206E756D62-
52 00000023 65723A2000
 \end{Verbatim}
 첫 번재 열은 각 행의 번호를 표시하고 두 번째 열은 세그먼트의 데이타의 오프셋을 16 진수로 나타낸다. 세 번째 열은 저장될 16 진수 값을 보여준다. 위 경우 그 값은
 아스키코드 값과 대응이 된다. 마지막으로 소스 파일의 코드가 나타나게 된다. 두 번째 열에 나타나는 오프셋은 실제 프로그램에서의 데이터의 오프셋과 다를
 가능성이 \emph{매우} 높다. 각각의 모듈은 데이터 세그먼트(를 포함한 다른 세그먼트들에서도) 에서의 자신만의 라벨을 가지고 있다.  링크 과정에선 
 (~\ref{seq:linking}참조) 에선 모든 데이터 세그먼트의 라벨들의 정의가 하나의 데이터 세그먼트로 통합된다. 그리고 마지막으로 정리된 오프셋들은 링커에 의해 
 계산된다. 

아래 소스코드의 ~54 에서 56 행의 텍스트 세그먼트의 리스트 파일에서 해당되는 부분을 보여주고 있다. 

\begin{Verbatim}[xleftmargin=\AsmMargin]
94 0000002C A1[00000000]          mov     eax, [input1]
95 00000031 0305[04000000]        add     eax, [input2]
96 00000037 89C3                  mov     ebx, eax
\end{Verbatim}
3 번째 열은 어셈블리에 의해 만들어진 기계어 코드를 보여준다. 보통 명령어들의 완전한 코드는 아직 계산되지 못한다. 예를 들어서 ~94 행에서 {\code input1} 의
오프셋(혹은 주소) 은 코드가 링크 되기 전 까지는 확실히 알 수 없다. 어셈블러는 {\code mov} 명령의 연산 부호(Opcode) 는 계산할 수 있지만 (이는 A1 에 
나타남) 대괄호 안의 정확한 값은 알 수 없다. 위 경우 어셈블러는 위 파일에서 정의된 bss 세그먼트의 시작을 임시적으로 오프셋 0 으로 하였다. 이것이
프로그램의 마지막 bss 세그먼트의 시작을 의미한다는 것이 \emph{아니} 라는 사실을 명심하여라. 코드가 링크가 된다면 링커는 정확한 오프셋 값을 그 자리에
집어 넣을 것이다. 다른 명령들의 경우, 예를 들어 ~96 행을 본다면 어떠한 라벨도 참조하지 않음을 알 수 있다. 여기에선 어셈블러가 정확한 기계어 코드를 
계산할 수 있다. 

\index{리스팅 파일|)}

\subsubsection{빅, 리틀 엔디안 표현 \index{엔디안|(}}
~95 행을 자세히 본다면 기계어 코드의 대괄호 속에 있는 오프셋 값이 매우 이상하다는 것을 알 수 있다. {\code input2} 라벨은 오프셋 4 (파일에 정의되어 있는 대로)
이다. 그러나, 메모리에서의 오프셋은 00000004 가 아니라 04000000 이다! 왜냐하면 프로세서가 정수를 메모리 상에 다른 순서로 저장하기 때문이다. 정수를 저장하는
방법에는 대표적으로 2 가지 방법이 있다. \emph{빅 엔디안(Big endian)} 과 \emph{리틀 엔디안(Little endian)} 이 그것이다. 빅 엔디안은 우리가 생각하는 그대로
정수를 저장한다. 가장 큰 바이트(\emph{i.e.} 가장 상위 바이트) 가 먼저 저장되고 가장 하위 바이트가 나중에 저장된다. 예를 들어서 dword 00000004 는 4 개의 바이
트 00~00~00~04 로 저장된다. IBM 메인 프레임, 대부분의 RISC 프로세서, 그리고 모토롤라 프로세서 들은 빅 엔디안 방법을 이용한다. 그러나 인텔 기반의 프로세서
는 모두 리틀 엔디안 방식을 이용한다. 여기서는 하위 바이트가 먼저 저장된다. 따라서 00000004 는 메모리 상에 04~00~00~00 으로 저장된다. 이 형식은 CPU
에 따라 정해져 있어서 바뀔 수 없다. 보통 프로그래머는 어떤 방식을 사용하느냐를 구별한 필요가 없다. 그러나 이 사실을 아는 것이 중요한 이유가 몇 가지 있는데

\begin{enumerate}
\item 이진 데이터가 서로 다른 컴퓨터로 전송될 때 (파일 또는
      네트워크를 통해서 ).
\item 멀티바이트(multibyte) 정수 데이터가 메모리에 쓰이고  
      개개의 바이트로 읽어 질 때(\emph{역도 같음})
\end{enumerate}

엔디안 표현은 배열의 원소들의 순서에 대해서는 영향을 주지 않는다. 배열의 첫 번째 원소는 언제나 최하위의 주소를 갖는다. 이는 문자열(단지 문자들의 배열인)
에서도 해당된다. 엔디안 표현은 단지 배열의 개개의 원소들에 대해서만 영향을 줄 뿐이다. 
\index{엔디안|)}

\begin{figure}[t]
\begin{AsmCodeListing}[label=skel.asm]
%include "asm_io.inc"
segment .data
;
; 초기화된 데이터는 여기 데이타 세그먼트에 들어간다. 
;

segment .bss
;
; 초기화 되지 않은 데이터는 여기 bss 세그먼트에 들어간다. 
;

segment .text
        global  _asm_main
_asm_main:
        enter   0,0               ; 셋업 루틴
        pusha

;
; 코드는 텍스트 세그먼트에 들어간다. 이 주석 앞 뒤의 코드를
; 수정하지 마세요 
;

        popa
        mov     eax, 0            ; C 로 리턴된다. 
        leave                     
        ret
\end{AsmCodeListing}
\caption{뼈대 프로그램\label{fig:skel}}
\end{figure}

\section{뼈대 파일 \index{뼈대 파일}}

그림 ~\ref{fig:skel} 은 뼈대 파일(Skeleton file) 을 보여준다. 어셈블리 프로그램 코딩시 매번 같은 내용을 작성하기보단 위 코드를 기준으로 시작하면
편리하다. 






